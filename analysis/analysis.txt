Put your name and netid here
Brian Du
bd121

(1) Run the program BenchmarkForAutocomplete and copy/paste the 
results here this for #matches = 20

search	size	#match	binary	brute
	456976		20	0,0147	0,0135
a	17576		20	0,0185	0,0190
b	17576		20	0,0098	0,0050
c	17576		20	0,0055	0,0045
x	17576		20	0,0053	0,0046
y	17576		20	0,0048	0,0046
z	17576		20	0,0047	0,0064
aa	676			20	0,0050	0,0045
az	676			20	0,0046	0,0046
za	676			20	0,0046	0,0045
zz	676			20	0,0046	0,0045

(2) Run the program again for #matches = 10000, paste the results, 
and then make any conclusions about how the # matches 
effects the runtime. 

search	size	#match	binary	brute
	456976	10000	0,0309	0,0349
a	17576	10000	0,0170	0,0183
b	17576	10000	0,0161	0,0109
c	17576	10000	0,0112	0,0115
x	17576	10000	0,0139	0,0129
y	17576	10000	0,0142	0,0106
z	17576	10000	0,0114	0,0107
aa	676		10000	0,0051	0,0049
az	676		10000	0,0056	0,0053
za	676		10000	0,0092	0,0060
zz	676		10000	0,0059	0,0056

The number of matches matters more when the size N is larger such as when N = 456976. The runtime for #matches=20
is significantly less than for #matches=10000, and this may be because there is so many more Terms to look through.
When size N is small, the #matches makes very little difference.

(3) Copy/paste the code from BruteAutocomplete.topMatches below. 
Explain what the Big-Oh complexity of the entire loop: 
for(Term t : myTerms) {...} 
is in terms of N, the number of elements in myTerms and 
M, the number of terms that match the prefix. 
Assume that every priority-queue operation runs in O(log k) time. 
Explain your answer which should be in terms of N, M, and k.

@Override
	public List<Term> topMatches(String prefix, int k) {
		if (k < 0) {
			throw new IllegalArgumentException("Illegal value of k:"+k);
		}
		
		// maintain pq of size k
		PriorityQueue<Term> pq = new PriorityQueue<Term>(10, new Term.WeightOrder());
		for (Term t : myTerms) {
			if (!t.getWord().startsWith(prefix))
				continue;
			if (pq.size() < k) {
				pq.add(t);
			} else if (pq.peek().getWeight() < t.getWeight()) {
				pq.remove();
				pq.add(t);
			}
		}
		int numResults = Math.min(k, pq.size());
		LinkedList<Term> ret = new LinkedList<>();
		for (int i = 0; i < numResults; i++) {
			ret.addFirst(pq.remove());
		}
		return ret;
	}

	The for (Term t : myTerms) { loop has runtime complexity of N + Mlogk because it will look through
	all N terms in MyTerms. Of the N terms, there will be M matches, and k of them are loaded into a 
	PriorityQueue for Mlogk complexity. Thus the total complexity is N + Mlogk.  
(4) Explain why the last for loop in BruteAutocomplete.topMatches 
uses a LinkedList (and not an ArrayList) 
AND why the PriorityQueue uses Term.WeightOrder to get 
the top k heaviest matches -- rather than 
using Term.ReverseWeightOrder.

A LinkedList is used instead of an ArrayList because adding to the front of a LinkedList is more efficient
since all the elements do not need to shift one index as they do in an ArrayList. Term.WeightOrder is used
instead of Term.ReverseWeightOrder because with the weights arranged in ascending order in the Queue, the
terms with the heaviest weight will be the first taken from the PriorityQueue. Thus only the first k
terms need to be taken from the PriorityQueue.

(5) Explain what the runtime of the 
BinarySearchAutocomplete.topMatches code that you 
implemented is by copy/pasting the code below 
and explaining your answer in terms of N, M, and k.

@Override
	public List<Term> topMatches(String prefix, int k) {

		if(prefix == null )
			throw new NullPointerException("prefix is null");
		
		if (k < 0) {
			throw new IllegalArgumentException("Illegal value of k:"+k);
		}
		
		// maintain pq of size k
		PriorityQueue<Term> pq = new PriorityQueue<Term>(10, new Term.WeightOrder());
		for (Term t : myTerms) {
			if (!t.getWord().startsWith(prefix))
				continue;
			if (pq.size() < k) {
				pq.add(t);
			} else if (pq.peek().getWeight() < t.getWeight()) {
				pq.remove();
				pq.add(t);
			}
		}
		int numResults = Math.min(k, pq.size());
		LinkedList<Term> ret = new LinkedList<>();
		for (int i = 0; i < numResults; i++) {
			ret.addFirst(pq.remove());
		}
		return ret;
	}
}


